Starting a django project:
==========================

Now that we have installed django, we are ready to start our project.

A project in django is analogous to a website. Once we have a project ready,
we can host it using any wsgi supported server. More on deploying a django project
later.

django-admin.py is a project utility that ships with django. In addition to the `startproject`
command, it also includes a lot of helper commands that can be useful while maintaining a django
project.

*Tip* 

    To get a full listing of available subcommands in django-admin.py, use

        django-admin.py --help

    To get help on each subcommand, use

        django-admin.py help <subcommand>

    For example, here's the result of `django-admin.py help startproject`:

        Creates a Django project directory structure for the given project name in the current directory.

Lets create a project called djen_project:

    django-admin.py startproject djen_project

We can see that the command creates a folder called djen_project in the working directory with the following files:

    __init__.py
    manage.py
    settings.py
    urls.py

__init__.py is an empty file required to recognize this project as a python module.

manage.py is a script that is similar to django-admin.py which allows you to manage this project. It has 
subcommands to start a development server, interact with database, backup/restore data etc.

*Tip*

    manage.py also has --help switch and help with each subcommand similar to django-admin.py

settings.py is a list of project wide settings with sane default values. You will need to edit this often when
installing new django applications, deployment etc.

*Notes*

    It is advised to have a local_settings.py file with exclusively sensitive settings like database username/password,
    API keys or Secret Key etc and have settings.py import all these values.

urls.py is a 'table of contents' of our project (or website). It includes a list of the paths that are to be processed
and responded to.

You are encouraged to go through settings.py and urls.py once to get an understanding of how settings and urls are defined.

Getting started with the App:
=============================

Now that we have setup and understood the structure of our project, we can start our application.

To start an application, cd into the project directory and use

    manage.py startapp cd_library

This will create a folder called cd_library with the  following files:

    __init__.py
    models.py
    tests.py
    views.py

__init__.py is again the file that allows this app to be considered a python module.

models.py will hold the Models of our application. A model is an object of our interest which we want to 
save to the database. If you are familiar with Model-View-Controller(MVC) architecture, you know what models are.
If no, don't worry, we will see and use them in our application.

views.py has all the 'action' of our website. This is similar to the Controller of MVC architecture. Each 'view' function
takes a `request` object and returns a `HttpResponse` object.

*Notes*

    It is recommended to have another urls.py (like the one in project) in the app and include them in the project urls.
    This reduces the clutter in the project urls and provides a namespace kind of resolution between urls. Also, it makes
    it easier to redistribute the app to other projects. As you would expect, reusable apps will depend on the project as 
    little as possible.

Let us create our models first:

Open models.py and define our `CD` model which will hold all information related to a CD. You can see that models.py has

   from django.db import models

   # Create your models here.

So we define the `CD` model as

    GENRE_CHOICES = (
                     ('R', 'Rock'), 
                     ('B', 'Blues'),
                     ('J', 'Jazz'),
                     ('P', 'Pop'),
                    )

    class CD(models.Model):
        title = models.CharField(max_length=100)
        description = models.TextField(null=True, blank=True)
        artist = models.CharField(max_length=40)
        date = models.DateField()
        genre = models.CharField(max_length=1, choices=GENRE_CHOICES)

        def __unicode__(self):
            return "%s by %s, %s" %(self.title, self.artist, self.date.year)

A little explanation:

* All models should be a subclass of django.db.models.Model

* Each model has a list of fields which will define that model

* We have used CharField, TextField and DateField in this model.

* Each CharField requires a max_length argument which specifies the maximum length of the characters that 
  the field can hold.

* A TextField can contain any number of characters and is suitable for fields such as description, summary, content etc.

* To make the description field optional, we pass the `null` and `blank` arguments as True

* DateField holds a date. If you need to store the time too, use DateTimeField instead.

* The `genre` field should be restricted to a group of values and that can be accomplished by passing an iterable of 2-tuples
  for the value and representation as the choices argument of the CharField.

* The __unicode__ property of the model defines it's string representation which will be used in the Admin interface, shell etc.

So far, we have defined the CD model, now we need to get it rolling in django:

First, let django know that `cd_library` is to be used in the project. To do this, edit the project settings.py and add

    `cd_library`

to the INSTALLED_APPS list so that your settings.py looks like this:

    INSTALLED_APPS = ( 
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        'django.contrib.messages',
        # Uncomment the next line to enable the admin:
        # 'django.contrib.admin',
        'cd_library',
    )

Well, now that django knows about our app, let us add it to the Admin interface.

A little bit about the admin interface first:

* The admin interface is itself a django app.

* It is a contrib app, which means it is a community contributed app

* It is flexible enough to accomodate any other app's models and have admin actions for them.

Since the admin is an app, it needs to be added to INSTALLED_APPS as well. You would have noticed this in the commented lines above.

So just go ahead and uncomment the django.contrib.admin line in settings.py under INSTALLED_APPS

Now we have similar instructions in urls.py to uncomment a few lines to enable the admin. This will enable the urls beginning with
`admin` to be mapped to the admin app's urls. Note that the admin app uses a urls.py to keep the app's urls separate from the project
as discussed above.
